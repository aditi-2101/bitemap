// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: restaurants.sql

package db

import (
	"context"
)

const addReview = `-- name: AddReview :one
INSERT INTO reviews (user_id, res_id, review, rating)
VALUES ($1, $2, $3, $4) RETURNING review_id, user_id, res_id, review, rating
`

type AddReviewParams struct {
	UserID *int32   `json:"user_id"`
	ResID  *int32   `json:"res_id"`
	Review *string  `json:"review"`
	Rating *float32 `json:"rating"`
}

func (q *Queries) AddReview(ctx context.Context, arg AddReviewParams) (Review, error) {
	row := q.db.QueryRow(ctx, addReview,
		arg.UserID,
		arg.ResID,
		arg.Review,
		arg.Rating,
	)
	var i Review
	err := row.Scan(
		&i.ReviewID,
		&i.UserID,
		&i.ResID,
		&i.Review,
		&i.Rating,
	)
	return i, err
}

const getRestaurantCuisines = `-- name: GetRestaurantCuisines :many
SELECT category
FROM restaurants
WHERE ST_DWithin(ST_Transform(geom, 900913), ST_Transform(ST_SetSRID(ST_Point($1::float, $2::float), 4326), 900913), $3::int)
`

type GetRestaurantCuisinesParams struct {
	Long     float64 `json:"long"`
	Lat      float64 `json:"lat"`
	Distance int32   `json:"distance"`
}

func (q *Queries) GetRestaurantCuisines(ctx context.Context, arg GetRestaurantCuisinesParams) ([]*string, error) {
	rows, err := q.db.Query(ctx, getRestaurantCuisines, arg.Long, arg.Lat, arg.Distance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var category *string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRestaurants = `-- name: GetRestaurants :many
SELECT id, name, score, ratings, category, price_range, full_address, zip_code, ST_AsGeoJSON(geom)
FROM restaurants
WHERE ST_DWithin(ST_Transform(geom, 900913), ST_Transform(ST_SetSRID(ST_Point($1::float, $2::float), 4326), 900913), $3::int)
`

type GetRestaurantsParams struct {
	Long     float64 `json:"long"`
	Lat      float64 `json:"lat"`
	Distance int32   `json:"distance"`
}

type GetRestaurantsRow struct {
	ID          int32       `json:"id"`
	Name        *string     `json:"name"`
	Score       *string     `json:"score"`
	Ratings     *int32      `json:"ratings"`
	Category    *string     `json:"category"`
	PriceRange  *string     `json:"price_range"`
	FullAddress *string     `json:"full_address"`
	ZipCode     *string     `json:"zip_code"`
	StAsgeojson interface{} `json:"st_asgeojson"`
}

func (q *Queries) GetRestaurants(ctx context.Context, arg GetRestaurantsParams) ([]GetRestaurantsRow, error) {
	rows, err := q.db.Query(ctx, getRestaurants, arg.Long, arg.Lat, arg.Distance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRestaurantsRow{}
	for rows.Next() {
		var i GetRestaurantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Ratings,
			&i.Category,
			&i.PriceRange,
			&i.FullAddress,
			&i.ZipCode,
			&i.StAsgeojson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRestaurantsByFilter = `-- name: GetRestaurantsByFilter :many
SELECT name, score, ratings, category, price_range, full_address, zip_code, ST_AsGeoJSON(geom)
FROM restaurants
WHERE category ilike $1 AND price_range = $2 AND cast(score as float) >= $3::float AND id = ANY($4::int[])
`

type GetRestaurantsByFilterParams struct {
	Category   *string `json:"category"`
	PriceRange *string `json:"price_range"`
	Ratings    float64 `json:"ratings"`
	Ids        []int32 `json:"ids"`
}

type GetRestaurantsByFilterRow struct {
	Name        *string     `json:"name"`
	Score       *string     `json:"score"`
	Ratings     *int32      `json:"ratings"`
	Category    *string     `json:"category"`
	PriceRange  *string     `json:"price_range"`
	FullAddress *string     `json:"full_address"`
	ZipCode     *string     `json:"zip_code"`
	StAsgeojson interface{} `json:"st_asgeojson"`
}

func (q *Queries) GetRestaurantsByFilter(ctx context.Context, arg GetRestaurantsByFilterParams) ([]GetRestaurantsByFilterRow, error) {
	rows, err := q.db.Query(ctx, getRestaurantsByFilter,
		arg.Category,
		arg.PriceRange,
		arg.Ratings,
		arg.Ids,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRestaurantsByFilterRow{}
	for rows.Next() {
		var i GetRestaurantsByFilterRow
		if err := rows.Scan(
			&i.Name,
			&i.Score,
			&i.Ratings,
			&i.Category,
			&i.PriceRange,
			&i.FullAddress,
			&i.ZipCode,
			&i.StAsgeojson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviews = `-- name: GetReviews :many
SELECT review_id, review, u.username, r.rating
FROM reviews r
JOIN users u ON r.user_id = u.user_id
WHERE r.res_id = $1::int
`

type GetReviewsRow struct {
	ReviewID int32    `json:"review_id"`
	Review   *string  `json:"review"`
	Username *string  `json:"username"`
	Rating   *float32 `json:"rating"`
}

func (q *Queries) GetReviews(ctx context.Context, resID int32) ([]GetReviewsRow, error) {
	rows, err := q.db.Query(ctx, getReviews, resID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReviewsRow{}
	for rows.Next() {
		var i GetReviewsRow
		if err := rows.Scan(
			&i.ReviewID,
			&i.Review,
			&i.Username,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRating = `-- name: UpdateRating :one
UPDATE restaurants 
SET score=cast(round(cast(((cast(score as float)*cast(ratings as float))+$2::float)/((cast(ratings as float))+1.0) as numeric),1) as varchar), ratings=ratings+1 
WHERE id=$1
RETURNING id
`

type UpdateRatingParams struct {
	ID     int32   `json:"id"`
	Rating float64 `json:"rating"`
}

func (q *Queries) UpdateRating(ctx context.Context, arg UpdateRatingParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateRating, arg.ID, arg.Rating)
	var id int32
	err := row.Scan(&id)
	return id, err
}
